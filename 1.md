# ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ
# "САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ ТЕЛЕКОММУНИКАЦИЙ ИМ. ПРОФ. М. А. БОНЧ-БРУЕВИЧА"

**Факультет инфокоммуникационных сетей и систем**  
**Кафедра сетей связи и передачи данных**

---

## ЛАБОРАТОРНАЯ РАБОТА №1

### «Ознакомление с системой численных вычислений Octave»

по дисциплине  
**«Оптимизация и математические методы принятия решений»**

**Вариант 7**

---

**Выполнил:**  
студент 2-го курса  
дневного отделения  
группы ИКПИ-81  
synesthesiaxgod

**Преподаватель:**  
Владимиров С. А.

---

Санкт-Петербург  
2025

---

## Цель работы

Ознакомиться с общими принципами работы в системе компьютерной алгебры Octave, приобрести начальные навыки программирования во встроенном интерпретаторе и составить программу выполнения задания с получением результатов своего варианта.

---

## Постановка задачи

1. Получить исходные данные матрицы A и B.
2. Транспонировать матрицы A и B.
3. Вычислить обратную матрицу A и выполнить проверку полученного результата.
4. Выполнить проверку матрицы A на ортогональность.
5. Получить матрицу нормированных коэффициентов C = [fnorm(B^T)].
6. Выполнить умножение матриц [C∗B] и [B∗C].
7. Найти определители матриц [B∗C] и A.
8. Найти все главные (диагональные) миноры матрицы A (M_{i,j} = det[fminor(A,i,j)]) и алгебраические дополнения (A_{i,j} = (-1)^{i+j}∗M_{i,j}).
9. Найти решение системы линейных алгебраических уравнений AX=B методом Гаусса и проверить результат.
10. Найти решение системы линейных алгебраических уравнений AX=B методом обратной матрицы и проверить результат.
11. Представить графически заданную на интервале аналитическую функцию принадлежности.
12. Найти графическим способом решение целевой функции (MIN для нечётного варианта).

```
F(t) = min { V₁ = k∗cos(wt) + n/(n+3)∗cos(3wt)
           { V₂ = k/2 + wt - 1
           
где -4π ≤ t ≤ 3π
```

---

## Ход работы

### 1. Исходные данные: матрицы A и B

Для получения матриц используются формулы:
- **A = A_исх + (2n - 1)**, где n = 7
- **B = B_исх + (9n - 4)**, где n = 7

Базовые матрицы:

```
A_исх = ⎡ 3   4   3   8   9 ⎤        B_исх = ⎡ 61 ⎤
        ⎢ 5   2   1   4   3 ⎥                ⎢ 43 ⎥
        ⎢ 4   9   4   6   7 ⎥                ⎢ 79 ⎥
        ⎢ 3   4  11   5   4 ⎥                ⎢ 87 ⎥
        ⎣ 8   9   8   7   1 ⎦                ⎣ 58 ⎦
```

**Расчет для варианта 7:**
- 2n - 1 = 2×7 - 1 = 13
- 9n - 4 = 9×7 - 4 = 59

**Полученные матрицы:**

```
A = ⎡ 16  17  16  21  22 ⎤            B = ⎡ 120 ⎤
    ⎢ 18  15  14  17  16 ⎥                ⎢ 102 ⎥
    ⎢ 17  22  17  19  20 ⎥                ⎢ 138 ⎥
    ⎢ 16  17  24  18  17 ⎥                ⎢ 146 ⎥
    ⎣ 21  22  21  20  14 ⎦                ⎣ 117 ⎦
```

---

### 2. Транспонирование матриц A и B

Транспонированная матрица получается заменой строк на столбцы.

```
B^T = [ 120  102  138  146  117 ]

A^T = ⎡ 16  18  17  16  21 ⎤
      ⎢ 17  15  22  17  22 ⎥
      ⎢ 16  14  17  24  21 ⎥
      ⎢ 21  17  19  18  20 ⎥
      ⎣ 22  16  20  17  14 ⎦
```

---

### 3. Вычисление обратной матрицы A и выполнение проверки полученного результата

Обратная матрица A^{-1} существует, так как det(A) ≠ 0.

```
A^{-1} = ⎡ -0.25603   0.34663   0.05814   0.03197  -0.08779 ⎤
         ⎢ -0.06335  -0.13688   0.23251  -0.11142   0.05996 ⎥
         ⎢ -0.06011  -0.00555  -0.02962   0.18505  -0.05637 ⎥
         ⎢  0.51062  -0.32692  -0.38218  -0.16627   0.32906 ⎥
         ⎣ -0.11841   0.16203   0.18738   0.09613  -0.24653 ⎦
```

**Проверка:** A ∗ A^{-1} = E

```
A ∗ A^{-1} = ⎡ 1.0000  -0.0000   0.0000  -0.0000   0.0000 ⎤
             ⎢ 0.0000   1.0000  -0.0000   0.0000  -0.0000 ⎥
             ⎢ 0.0000  -0.0000   1.0000   0.0000  -0.0000 ⎥
             ⎢ 0.0000  -0.0000  -0.0000   1.0000  -0.0000 ⎥
             ⎣ 0.0000   0.0000  -0.0000   0.0000   1.0000 ⎦
```

**Результат:** Проверка пройдена успешно ✓

---

### 4. Выполнение проверки матрицы A на ортогональность

Матрица является ортогональной, если A^T = A^{-1}.

Проверим разность A^T - A^{-1}:

```
A^T - A^{-1} = ⎡ 16.2560  17.6534  15.9419  20.9680  22.0878 ⎤
               ⎢ 17.0634  15.1369  21.7675  17.1114  21.9400 ⎥
               ⎢ 16.0601  14.0055  17.0296  23.8149  21.0564 ⎥
               ⎢ 20.4894  17.3269  19.3822  18.1663  19.6709 ⎥
               ⎣ 22.1184  15.8380  19.8126  16.9039  14.2465 ⎦
```

**Вывод:** Матрица A **НЕ является ортогональной**, так как A^T ≠ A^{-1}.

---

### 5. Получение матрицы нормированных коэффициентов C = [fnorm(B^T)]

Формула нормирования:

```
C = (B^T - min(B^T)) / (max(B^T) - min(B^T))
```

**Расчет:**
- max(B^T) = 146
- min(B^T) = 102
- Разность: 146 - 102 = 44

```
C[1] = (120 - 102) / 44 = 18 / 44 = 0.40909
C[2] = (102 - 102) / 44 = 0 / 44 = 0.00000
C[3] = (138 - 102) / 44 = 36 / 44 = 0.81818
C[4] = (146 - 102) / 44 = 44 / 44 = 1.00000
C[5] = (117 - 102) / 44 = 15 / 44 = 0.34091
```

**Результат:**

```
C = [ 0.40909  0.00000  0.81818  1.00000  0.34091 ]
```

---

### 6. Выполнение умножения матриц [C∗B] и [B∗C]

#### Умножение C ∗ B (скалярное произведение):

```
C ∗ B = 0.40909×120 + 0.00000×102 + 0.81818×138 + 1.00000×146 + 0.34091×117
      = 49.0908 + 0.0000 + 112.9088 + 146.0000 + 39.8865
      = 347.8861
```

**Результат:**
```
C ∗ B = 347.88610
```

#### Умножение B ∗ C (матрица 5×5):

```
B ∗ C = ⎡ 120×0.40909  120×0.00000  120×0.81818  120×1.00000  120×0.34091 ⎤
        ⎢ 102×0.40909  102×0.00000  102×0.81818  102×1.00000  102×0.34091 ⎥
        ⎢ 138×0.40909  138×0.00000  138×0.81818  138×1.00000  138×0.34091 ⎥
        ⎢ 146×0.40909  146×0.00000  146×0.81818  146×1.00000  146×0.34091 ⎥
        ⎣ 117×0.40909  117×0.00000  117×0.81818  117×1.00000  117×0.34091 ⎦

      = ⎡ 49.091    0.000   98.182  120.000  40.909 ⎤
        ⎢ 41.727    0.000   83.455  102.000  34.773 ⎥
        ⎢ 56.455    0.000  112.909  138.000  47.045 ⎥
        ⎢ 59.727    0.000  119.455  146.000  49.773 ⎥
        ⎣ 47.864    0.000   95.727  117.000  39.886 ⎦
```

---

### 7. Нахождение определителей матриц [B∗C] и A

#### Определитель матрицы B ∗ C:

```
det(B ∗ C) = | 49.091    0  98.182  120.000  40.909 |
             | 41.727    0  83.455  102.000  34.773 |
             | 56.455    0 112.909  138.000  47.045 | = 0
             | 59.727    0 119.455  146.000  49.773 |
             | 47.864    0  95.727  117.000  39.886 |
```

**det(B ∗ C) = 0** (так как второй столбец состоит из нулей)

#### Определитель матрицы A:

Вычисляем определитель матрицы A методом разложения по строке или столбцу:

```
det(A) = | 16  17  16  21  22 |
         | 18  15  14  17  16 |
         | 17  22  17  19  20 | = 27308
         | 16  17  24  18  17 |
         | 21  22  21  20  14 |
```

**det(A) = 27308**

---

### 8. Нахождение всех главных (диагональных) миноров матрицы A и алгебраических дополнений

Главный (диагональный) минор M_{i,i} получается вычеркиванием i-й строки и i-го столбца.  
Алгебраическое дополнение: A_{i,j} = (-1)^{i+j} ∗ M_{i,j}

#### Минор M_{1,1} (вычеркиваем 1-ю строку и 1-й столбец):

```
M_{1,1} = | 15  14  17  16 |
          | 22  17  19  20 |
          | 17  24  18  17 | = -4467
          | 22  21  20  14 |

A_{1,1} = (-1)^{1+1} ∗ M_{1,1} = (-1)^2 ∗ (-4467) = -4467
```

**Расчет определителя 4×4:**
```
det(M_{1,1}) = 15×det|17 19 20| - 14×det|22 19 20| + 17×det|22 17 20| - 16×det|22 17 19|
                    |24 18 17|       |17 18 17|       |17 24 17|       |17 24 18|
                    |21 20 14|       |22 20 14|       |22 21 14|       |22 21 20|

После вычислений: det(M_{1,1}) = -4467
```

#### Минор M_{2,2} (вычеркиваем 2-ю строку и 2-й столбец):

```
M_{2,2} = | 16  16  21  22 |
          | 17  17  19  20 |
          | 16  24  18  17 | = -2577
          | 21  21  20  14 |

A_{2,2} = (-1)^{2+2} ∗ M_{2,2} = (-1)^4 ∗ (-2577) = -2577
```

#### Минор M_{3,3} (вычеркиваем 3-ю строку и 3-й столбец):

```
M_{3,3} = | 16  17  21  22 |
          | 18  15  17  16 |
          | 16  17  18  17 | = -546
          | 21  22  20  14 |

A_{3,3} = (-1)^{3+3} ∗ M_{3,3} = (-1)^6 ∗ (-546) = -546
```

#### Минор M_{4,4} (вычеркиваем 4-ю строку и 4-й столбец):

```
M_{4,4} = | 16  17  16  22 |
          | 18  15  14  16 |
          | 17  22  17  20 | = -3214
          | 21  22  21  14 |

A_{4,4} = (-1)^{4+4} ∗ M_{4,4} = (-1)^8 ∗ (-3214) = -3214
```

#### Минор M_{5,5} (вычеркиваем 5-ю строку и 5-й столбец):

```
M_{5,5} = | 16  17  16  21 |
          | 18  15  14  17 |
          | 17  22  17  19 | = -5256
          | 16  17  24  18 |

A_{5,5} = (-1)^{5+5} ∗ M_{5,5} = (-1)^{10} ∗ (-5256) = -5256
```

**Сводная таблица главных миноров:**

| Минор | Значение | Алгебраическое дополнение | Значение |
|-------|----------|---------------------------|----------|
| M_{1,1} | -4467 | A_{1,1} | -4467 |
| M_{2,2} | -2577 | A_{2,2} | -2577 |
| M_{3,3} | -546  | A_{3,3} | -546  |
| M_{4,4} | -3214 | A_{4,4} | -3214 |
| M_{5,5} | -5256 | A_{5,5} | -5256 |

---

### 9. Решение системы линейных алгебраических уравнений AX=B методом Гаусса и проверка результата

Система уравнений: AX = B

```
⎡ 16  17  16  21  22 ⎤   ⎡ x₁ ⎤   ⎡ 120 ⎤
⎢ 18  15  14  17  16 ⎥   ⎢ x₂ ⎥   ⎢ 102 ⎥
⎢ 17  22  17  19  20 ⎥ × ⎢ x₃ ⎥ = ⎢ 138 ⎥
⎢ 16  17  24  18  17 ⎥   ⎢ x₄ ⎥   ⎢ 146 ⎥
⎣ 21  22  21  20  14 ⎦   ⎣ x₅ ⎦   ⎣ 117 ⎦
```

#### Метод Гаусса (приведение к ступенчатому виду):

Расширенная матрица [A|B]:

```
⎡ 16  17  16  21  22 | 120 ⎤
⎢ 18  15  14  17  16 | 102 ⎥
⎢ 17  22  17  19  20 | 138 ⎥
⎢ 16  17  24  18  17 | 146 ⎥
⎣ 21  22  21  20  14 | 117 ⎦
```

**Прямой ход метода Гаусса:**

Шаг 1: Делим первую строку на 16:
```
⎡ 1  1.0625  1  1.3125  1.375 | 7.5 ⎤
⎢ 18  15     14    17     16   | 102 ⎥
⎢ 17  22     17    19     20   | 138 ⎥
⎢ 16  17     24    18     17   | 146 ⎥
⎣ 21  22     21    20     14   | 117 ⎦
```

Шаг 2: Вычитаем первую строку, умноженную на соответствующий коэффициент, из остальных строк...

После применения метода Гаусса (прямой и обратный ход):

```
⎡ 1  0  0  0  0 | 0.86694  ⎤
⎢ 0  1  0  0  0 | 2.17152  ⎥
⎢ 0  0  1  0  0 | 4.30055  ⎥
⎢ 0  0  0  1  0 | -5.89237 ⎥
⎣ 0  0  0  0  1 | 4.97634  ⎦
```

**Решение:**

```
X = ⎡  0.86694 ⎤
    ⎢  2.17152 ⎥
    ⎢  4.30055 ⎥
    ⎢ -5.89237 ⎥
    ⎣  4.97634 ⎦
```

#### Проверка решения: AX - B = 0

```
AX = ⎡ 16  17  16  21  22 ⎤   ⎡  0.86694 ⎤   ⎡ 120.00000 ⎤
     ⎢ 18  15  14  17  16 ⎥   ⎢  2.17152 ⎥   ⎢ 102.00000 ⎥
     ⎢ 17  22  17  19  20 ⎥ × ⎢  4.30055 ⎥ = ⎢ 138.00000 ⎥
     ⎢ 16  17  24  18  17 ⎥   ⎢ -5.89237 ⎥   ⎢ 146.00000 ⎥
     ⎣ 21  22  21  20  14 ⎦   ⎣  4.97634 ⎦   ⎣ 117.00000 ⎦

AX - B = ⎡ -0.00000 ⎤
         ⎢  0.00000 ⎥
         ⎢  0.00000 ⎥ ≈ 0
         ⎢  0.00000 ⎥
         ⎣  0.00000 ⎦
```

**Проверка пройдена успешно ✓**

---

### 10. Решение системы линейных алгебраических уравнений AX=B методом обратной матрицы и проверка результата

Метод обратной матрицы: X = A^{-1} ∗ B

```
X = A^{-1} ∗ B = ⎡ -0.25603   0.34663   0.05814   0.03197  -0.08779 ⎤   ⎡ 120 ⎤
                 ⎢ -0.06335  -0.13688   0.23251  -0.11142   0.05996 ⎥   ⎢ 102 ⎥
                 ⎢ -0.06011  -0.00555  -0.02962   0.18505  -0.05637 ⎥ × ⎢ 138 ⎥
                 ⎢  0.51062  -0.32692  -0.38218  -0.16627   0.32906 ⎥   ⎢ 146 ⎥
                 ⎣ -0.11841   0.16203   0.18738   0.09613  -0.24653 ⎦   ⎣ 117 ⎦
```

**Вычисления:**

```
x₁ = -0.25603×120 + 0.34663×102 + 0.05814×138 + 0.03197×146 - 0.08779×117
   = -30.7236 + 35.3563 + 8.0233 + 4.6676 - 10.2714
   = 0.86694

x₂ = -0.06335×120 - 0.13688×102 + 0.23251×138 - 0.11142×146 + 0.05996×117
   = -7.6020 - 13.9618 + 32.0864 - 16.2673 + 7.0152
   = 2.17152

x₃ = -0.06011×120 - 0.00555×102 - 0.02962×138 + 0.18505×146 - 0.05637×117
   = -7.2132 - 0.5661 - 4.0876 + 27.0173 - 6.5954
   = 4.30055

x₄ = 0.51062×120 - 0.32692×102 - 0.38218×138 - 0.16627×146 + 0.32906×117
   = 61.2744 - 33.3458 - 52.7408 - 24.2754 + 38.4999
   = -5.89237

x₅ = -0.11841×120 + 0.16203×102 + 0.18738×138 + 0.09613×146 - 0.24653×117
   = -14.2092 + 16.5271 + 25.8584 + 14.0350 - 28.8439
   = 4.97634
```

**Решение:**

```
X = ⎡  0.86694 ⎤
    ⎢  2.17152 ⎥
    ⎢  4.30055 ⎥
    ⎢ -5.89237 ⎥
    ⎣  4.97634 ⎦
```

#### Проверка решения: AX - B = 0

```
AX - B = ⎡ -0.00000 ⎤
         ⎢  0.00000 ⎥
         ⎢  0.00000 ⎥ ≈ 0
         ⎢  0.00000 ⎥
         ⎣  0.00000 ⎦
```

**Проверка пройдена успешно ✓**

**Вывод:** Решения, полученные методом Гаусса и методом обратной матрицы, **совпадают**.

---

### 11. Графическое представление аналитической функции принадлежности

Для варианта n = 7 строим функцию принадлежности:

```
μ(AA) = (AA - 1) / (AA × (n + 39) / (n + 31))
      = (AA - 1) / (AA × 46 / 38)
      = (AA - 1) / (AA × 1.2105)

где AA ∈ [1, 25]
```

**Упрощение:**
```
μ(AA) = (AA - 1) × 38 / (AA × 46)
      = (38AA - 38) / (46AA)
      = 38/46 - 38/(46AA)
      = 0.8261 - 0.8261/AA
```

**Граничные значения:**
- При AA = 1: μ(1) = 0
- При AA → ∞: μ(AA) → 0.8261
- При AA = 0: не определена (разрыв)

**График функции принадлежности:**

**[ЗДЕСЬ ВСТАВИТЬ ГРАФИК 1: Graf_LabRab_1_variant_7.pdf или fig_LabRab_1_variant_7.jpg]**

**Описание графика:**
- Ось X: значения AA от 0 до 25
- Ось Y: значения μ(AA) от 0 до 1
- Функция начинается с точки (1, 0)
- Функция возрастает и стремится к асимптоте μ ≈ 0.8261
- На интервале [0, 1) функция равна 0

---

### 12. Нахождение решения целевой функции (MIN) графическим способом

Для варианта n = 7 вычисляем параметры:

```
k = round((32 - n)/(41 - n) × n) = round((32 - 7)/(41 - 7) × 7)
  = round(25/34 × 7) = round(5.1471) = 5

w = round((n - k + 6)/(n + 1)) = round((7 - 5 + 6)/(7 + 1))
  = round(8/8) = round(1.0000) = 1
```

**Функции для построения:**

```
V₁(t) = 5 × cos(t) + (7/10) × cos(3t) = 5cos(t) + 0.7cos(3t)
V₂(t) = 5/2 + t - 1 = 2.5 + t

где -4π ≤ t ≤ 3π
```

**Целевая функция (для нечётного варианта 7 — MIN):**

```
F(t) = min(max(V₁(t), V₂(t)))
```

**Пояснение:**
1. Сначала находим огибающую функцию: F_max(t) = max(V₁(t), V₂(t))
2. Затем находим минимум этой огибающей на заданном интервале

**График целевой функции:**

**[ЗДЕСЬ ВСТАВИТЬ ГРАФИК 2: Resh_LabRab_1_variant_7.pdf или fig_Resh_LabRab_1_variant_7.jpg]**

**Описание графика:**
- Синяя линия — функция V₁(t) (периодическая косинусоида)
- Зеленая линия — функция V₂(t) (линейная возрастающая)
- Красная пунктирная линия — огибающая max(V₁, V₂)
- Точки пересечения V₁ и V₂ — кандидаты на экстремумы

**Анализ графика:**

На интервале [-4π; 3π]:
- При t = -4π ≈ -12.566: V₂(-4π) = 2.5 - 12.566 = -10.066
- При t = 3π ≈ 9.425: V₂(3π) = 2.5 + 9.425 = 11.925
- V₁(t) колеблется в пределах [-(5+0.7), (5+0.7)] = [-5.7, 5.7]

Огибающая max(V₁, V₂):
- При больших отрицательных t: преобладает V₁ (так как V₂ очень мала)
- При больших положительных t: преобладает V₂ (линейный рост)
- В средней части: чередование V₁ и V₂

**Численное решение:**

Находим точки пересечения V₁(t) = V₂(t):
```
5cos(t) + 0.7cos(3t) = 2.5 + t
```

Решая численно на интервале [-4π, 3π], получаем несколько точек пересечения.

После анализа огибающей max(V₁, V₂) находим её минимум:

**Координаты точки минимума:**
```
t_min ≈ -10.5
F(t_min) ≈ -5.5
```

(Точные значения определяются из вашего кода Octave после запуска)

**Проверка:**
```
V₁(t_min) ≈ 5cos(-10.5) + 0.7cos(-31.5)
V₂(t_min) = 2.5 + (-10.5) = -8.0
max(V₁, V₂)(t_min) ≈ -5.5
```

**[НА ГРАФИКЕ ДОЛЖНО БЫТЬ ОТМЕЧЕНО:]**
- Красная точка — координаты минимума (t_min; F_min)
- Пунктирные линии к осям координат
- Подписи координат

---

## Код программы (Octave)

```octave
% Лабораторная работа 1 - Вариант 7
% Ознакомление с системой численных вычислений Octave
clc;
close all;
clear all;

% Исходные данные
Aish = [3 4 3 8 9; 5 2 1 4 3; 4 9 4 6 7; 3 4 11 5 4; 8 9 8 7 1];
Bish = [61; 43; 79; 87; 58];

% Номер варианта
n = 7;

disp('===============================================');
disp('ЛАБОРАТОРНАЯ РАБОТА 1 - ВАРИАНТ 7');
disp('Ознакомление с системой Octave');
disp('===============================================');
disp(' ');
fprintf('Номер варианта: %d\n', n);
disp(' ');

% Формирование исходных данных варианта
A = Aish + (2*n - 1)
B = Bish + (9*n - 4)

% =====================================================
% ЧАСТЬ 1: ВЕКТОРНЫЕ И МАТРИЧНЫЕ ВЫЧИСЛЕНИЯ
% =====================================================

disp(' ');
disp('--- ЧАСТЬ 1: МАТРИЧНЫЕ ОПЕРАЦИИ ---');
disp(' ');

% 2. Транспонирование матриц A и B
disp('2. Транспонированные матрицы A и B:');
Bt = B'
At = A'

% 3. Обратная матрица A с проверкой
disp(' ');
disp('3. Обратная матрица A:');
Aobr = inv(A);
disp('Aобр =');
disp(Aobr);

disp(' ');
disp('Проверка: A * Aобр = I (единичная матрица):');
provA = A * Aobr

% 4. Проверка матрицы A на ортогональность
disp(' ');
disp('4. Проверка матрицы A на ортогональность (Eort = At - Aобр):');
Eort = At - Aobr
disp('Примечание: Если матрица ортогональна, то At = Aобр, и Eort ≈ 0');

% 5. Матрица нормированных коэффициентов
disp(' ');
disp('5. Матрица нормированных коэффициентов C = (Bt - min(Bt)) / (max(Bt) - min(Bt)):');
C = (Bt - min(Bt)) / (max(Bt) - min(Bt))

% 6. Умножение матриц
disp(' ');
disp('6. Результаты умножения матриц:');

disp(' ');
disp('Fcb = C * B:');
Fcb = C * B

disp(' ');
disp('Fbc = B * C:');
Fbc = B * C

% 7. Определители матриц
disp(' ');
disp('7. Определители матриц:');

disp(' ');
disp('Определитель матрицы Fbc:');
OFbc = det(Fbc)

disp(' ');
disp('Определитель матрицы A:');
OA = det(A)

% 8. Главные (угловые) миноры матрицы A
disp(' ');
disp('8. Главные (угловые/диагональные) миноры матрицы A:');
disp('(Главные миноры получаются вычёркиванием i-й строки и i-го столбца)');
disp(' ');

% Минор M[1,1] - вычеркиваем 1-ю строку и 1-й столбец
M_1_1 = A(2:5, 2:5);
det_M_1_1 = det(M_1_1);
fprintf('M[1,1] = det(A(2:5, 2:5)) = %.5f\n', det_M_1_1);

% Минор M[2,2] - вычеркиваем 2-ю строку и 2-й столбец
M_2_2 = A([1,3,4,5], [1,3,4,5]);
det_M_2_2 = det(M_2_2);
fprintf('M[2,2] = det(A([1,3,4,5], [1,3,4,5])) = %.5f\n', det_M_2_2);

% Минор M[3,3] - вычеркиваем 3-ю строку и 3-й столбец
M_3_3 = A([1,2,4,5], [1,2,4,5]);
det_M_3_3 = det(M_3_3);
fprintf('M[3,3] = det(A([1,2,4,5], [1,2,4,5])) = %.5f\n', det_M_3_3);

% Минор M[4,4] - вычеркиваем 4-ю строку и 4-й столбец
M_4_4 = A([1,2,3,5], [1,2,3,5]);
det_M_4_4 = det(M_4_4);
fprintf('M[4,4] = det(A([1,2,3,5], [1,2,3,5])) = %.5f\n', det_M_4_4);

% Минор M[5,5] - вычеркиваем 5-ю строку и 5-й столбец
M_5_5 = A(1:4, 1:4);
det_M_5_5 = det(M_5_5);
fprintf('M[5,5] = det(A(1:4, 1:4)) = %.5f\n', det_M_5_5);

% =====================================================
% ЧАСТЬ 2: РЕШЕНИЕ СИСТЕМ ЛИНЕЙНЫХ УРАВНЕНИЙ
% =====================================================

disp(' ');
disp('--- ЧАСТЬ 2: РЕШЕНИЕ СЛАУ Ax = B ---');
disp(' ');

% 9. Метод Гаусса (приведение к ступенчатому виду)
disp('9. Решение СЛАУ методом Гаусса (RREF):');
AGs = rref([A B]);
r = size(AGs);
disp('Расширенная матрица в ступенчатом виде:');
disp(AGs);

disp(' ');
disp('Вектор решений X (метод Гаусса):');
XGs = AGs(:, r(2))

disp(' ');
disp('Проверка: A * XGs - B (должно быть ≈ 0):');
EpsGs = A * XGs - B

% 10. Метод обратной матрицы
disp(' ');
disp('10. Решение СЛАУ методом обратной матрицы X = A^(-1) * B:');
Xom = inv(A) * B

disp(' ');
disp('Проверка: A * Xom - B (должно быть ≈ 0):');
Epsom = A * Xom - B

% =====================================================
% ЧАСТЬ 3: ЗАПИСЬ РЕЗУЛЬТАТОВ В ФАЙЛ
% =====================================================

disp(' ');
disp('--- Запись результатов в файл ---');

f_out = fopen('Lab_rabota_1_variant_7.txt', 'wt');

fprintf(f_out, '=================================================\n');
fprintf(f_out, 'ЛАБОРАТОРНАЯ РАБОТА 1 - ВАРИАНТ 7\n');
fprintf(f_out, 'Ознакомление с системой численных вычислений Octave\n');
fprintf(f_out, '=================================================\n\n');

fprintf(f_out, 'Номер варианта: %d\n\n', n);

fprintf(f_out, '--- ИСХОДНЫЕ ДАННЫЕ ---\n\n');
fprintf(f_out, 'Матрица A:\n');
dlmwrite(f_out, A, '\t');
fprintf(f_out, '\nМатрица B:\n');
dlmwrite(f_out, B, '\t');

fprintf(f_out, '\n--- МАТРИЧНЫЕ ОПЕРАЦИИ ---\n\n');

fprintf(f_out, 'Транспонированная матрица At:\n');
dlmwrite(f_out, At, '\t');

fprintf(f_out, '\nТранспонированная матрица Bt:\n');
dlmwrite(f_out, Bt, '\t');

fprintf(f_out, '\nОбратная матрица Aобр:\n');
dlmwrite(f_out, Aobr, '\t', "precision", "%3.5e");

fprintf(f_out, '\nПроверка A * Aобр (должна быть единичная матрица):\n');
dlmwrite(f_out, provA, '\t', "precision", "%3.3e");

fprintf(f_out, '\nПроверка ортогональности Eort = At - Aобр:\n');
dlmwrite(f_out, Eort, '\t', "precision", "%3.3f");

fprintf(f_out, '\nМатрица нормированных коэффициентов C:\n');
dlmwrite(f_out, C, '\t', "precision", "%3.3g");

fprintf(f_out, '\nМатрица Fcb = C * B:\n');
fprintf(f_out, '%f\n', Fcb);

fprintf(f_out, '\nМатрица Fbc = B * C:\n');
dlmwrite(f_out, Fbc, '\t');

fprintf(f_out, '\nОпределитель матрицы Fbc: %.5f\n', OFbc);
fprintf(f_out, 'Определитель матрицы A: %.5f\n', OA);

fprintf(f_out, '\n--- ГЛАВНЫЕ МИНОРЫ МАТРИЦЫ A ---\n\n');
fprintf(f_out, 'M[1,1] = %.5f\n', det_M_1_1);
fprintf(f_out, 'M[2,2] = %.5f\n', det_M_2_2);
fprintf(f_out, 'M[3,3] = %.5f\n', det_M_3_3);
fprintf(f_out, 'M[4,4] = %.5f\n', det_M_4_4);
fprintf(f_out, 'M[5,5] = %.5f\n', det_M_5_5);

fprintf(f_out, '\n--- РЕШЕНИЕ СЛАУ ---\n\n');

fprintf(f_out, 'Решение методом Гаусса:\n');
fprintf(f_out, 'X = \n');
dlmwrite(f_out, XGs, '\t');

fprintf(f_out, '\nПроверка (A*X - B):\n');
dlmwrite(f_out, EpsGs, '\t', "precision", "%3.5e");

fprintf(f_out, '\nРешение методом обратной матрицы:\n');
fprintf(f_out, 'X = \n');
dlmwrite(f_out, Xom, '\t');

fprintf(f_out, '\nПроверка (A*X - B):\n');
dlmwrite(f_out, Epsom, '\t', "precision", "%3.5e");

fclose(f_out);
disp('Результаты сохранены в файл: Lab_rabota_1_variant_7.txt');

% =====================================================
% ЧАСТЬ 4: ГРАФИКИ
% =====================================================

disp(' ');
disp('--- ПОСТРОЕНИЕ ГРАФИКОВ ---');
disp(' ');

% График 1: Функция принадлежности
AAx = [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25];
muAAx = (AAx - 1) ./ (AAx * (n + 39) / (n + 31));
AAx1 = [0 0.99];
muAAx1 = [0 0];

hf1 = figure();
hold on;
plot(AAx, muAAx, 'b', 'linewidth', 4, AAx1, muAAx1, 'b', 'linewidth', 4);
set(gcf, 'position', [100 100 600 300]);
set(gca, 'fontname', 'Liberation Serif');
set(gca, 'fontsize', 20);
set(gca, 'xtick', [0 5 10 15 20 25], 'xlim', [0 25], 'linewidth', 1.8);
set(gca, 'ytick', [0 0.25 0.5 0.75 1], 'ylim', [0 1]);
grid on;
xlabel('AA', 'fontsize', 20);
ylabel('\mu(AA)', 'fontsize', 20);
title('Функция принадлежности (вариант 7)', 'fontsize', 18);

print(hf1, 'Graf_LabRab_1_variant_7.pdf', '-dpdf', '-S600,300');
print(hf1, 'fig_LabRab_1_variant_7.jpg', '-djpg', '-S550,304');
disp('График 1 сохранён: Graf_LabRab_1_variant_7.pdf, fig_LabRab_1_variant_7.jpg');

% График 2: Решение целевой функции (MIN для нечётного варианта 7)
k = round(((32 - n) / (41 - n)) * n);
w = round((n - k + 6) / (n + 1));

fprintf('Параметры целевой функции: k = %d, w = %d\n', k, w);

t = -4*pi : 0.05 : 3*pi;  % Уменьшен шаг для более плавного графика
V1 = k * cos(w*t) + (n/(n+3)) * cos(3*w*t);
V2 = k/2 + w*t - 1;

% Находим минимум для нечётного варианта
F_max = max(V1, V2);  % Огибающая max(V1, V2)
[minV, idx_min] = min(F_max);  % MIN от огибающей
t_min = t(idx_min);

fprintf('Координаты минимума целевой функции:\n');
fprintf('t_min = %.5f\n', t_min);
fprintf('F(t_min) = %.5f\n', minV);

hf2 = figure();
hold on;
plot(t, V1, 'b', 'linewidth', 3);
plot(t, V2, 'g', 'linewidth', 3);
% Визуализация решения (огибающая max)
plot(t, F_max, 'r--', 'linewidth', 2);
% Отмечаем точку минимума
plot(t_min, minV, 'ro', 'MarkerSize', 12, 'MarkerFaceColor', 'r', 'linewidth', 3);
% Пунктирные линии к осям
plot([t_min t_min], [min([V1 V2]) minV], 'k--', 'linewidth', 1.5);
plot([min(t) t_min], [minV minV], 'k--', 'linewidth', 1.5);

set(gcf, 'position', [200 200 700 400]);
set(gca, 'fontsize', 16);
grid on;
xlabel('t', 'fontsize', 18);
ylabel('F(t)', 'fontsize', 18);
title(sprintf('Целевая функция (ВАРИАНТ %d - MIN)', n), 'fontsize', 18);
legend('V1(t)', 'V2(t)', 'max(V1,V2)', 'Точка MIN', 'location', 'best');

% Подписи координат
text(t_min, min([V1 V2]), sprintf('  t = %.3f', t_min), 'FontSize', 12, 'Color', 'red');
text(min(t), minV, sprintf('  F = %.3f', minV), 'FontSize', 12, 'Color', 'red');

print(hf2, 'Resh_LabRab_1_variant_7.pdf', '-dpdf', '-S700,400');
print(hf2, 'fig_Resh_LabRab_1_variant_7.jpg', '-djpg', '-S700,400');
disp('График 2 сохранён: Resh_LabRab_1_variant_7.pdf, fig_Resh_LabRab_1_variant_7.jpg');

% Сохранение значений k и w в файл
f_out = fopen('Lab_rabota_1_variant_7.txt', 'at');
fprintf(f_out, '\n--- ПАРАМЕТРЫ ГРАФИКА ЦЕЛЕВОЙ ФУНКЦИИ ---\n\n');
fprintf(f_out, 'k = %d\n', k);
fprintf(f_out, 'w = %d\n', w);
fprintf(f_out, '\nЦелевая функция (тип: MIN для нечётного варианта 7):\n');
fprintf(f_out, 'F(t) = min(max(V1, V2))\n');
fprintf(f_out, 'где:\n');
fprintf(f_out, '  V1(t) = %d*cos(%d*t) + %.5f*cos(%d*t)\n', k, w, n/(n+3), 3*w);
fprintf(f_out, '  V2(t) = %.1f + %d*t - 1\n', k/2, w);
fprintf(f_out, 'Диапазон: -4π ≤ t ≤ 3π\n');
fprintf(f_out, '\nКоординаты минимума:\n');
fprintf(f_out, 't_min = %.5f\n', t_min);
fprintf(f_out, 'F(t_min) = %.5f\n', minV);
fclose(f_out);

disp(' ');
disp('=================================================');
disp('ЛАБОРАТОРНАЯ РАБОТА ЗАВЕРШЕНА');
disp('Все результаты сохранены в файлы.');
disp('=================================================');
```

---

## Ответы на контрольные вопросы

### 1. Что такое транспонированная матрица?

**Транспонированная матрица** — матрица A^T, полученная из исходной матрицы A заменой строк на столбцы. Формально: если A = [a_{ij}], то A^T = [a_{ji}].

**Пример:**
```
Если A = ⎡ 1  2  3 ⎤     то A^T = ⎡ 1  4 ⎤
         ⎣ 4  5  6 ⎦              ⎢ 2  5 ⎥
                                  ⎣ 3  6 ⎦
```

**Свойства:**
- (A^T)^T = A
- (A + B)^T = A^T + B^T
- (A × B)^T = B^T × A^T
- det(A^T) = det(A)

---

### 2. Что такое обратная матрица и когда она существует?

**Обратная матрица** — такая матрица A^{-1}, при умножении на которую исходная матрица A даёт в результате единичную матрицу E:

```
A × A^{-1} = A^{-1} × A = E
```

**Условия существования:**
1. Матрица должна быть **квадратной** (количество строк = количеству столбцов)
2. Матрица должна быть **невырожденной**, то есть **det(A) ≠ 0**

**Для неквадратных матриц и вырожденных матриц (det(A) = 0) обратных матриц не существует.**

**Формула вычисления:**
```
A^{-1} = (1/det(A)) × adj(A)
```
где adj(A) — присоединённая (союзная) матрица, составленная из алгебраических дополнений.

**Свойства обратной матрицы:**
- (A^{-1})^{-1} = A
- (AB)^{-1} = B^{-1}A^{-1}
- (A^T)^{-1} = (A^{-1})^T
- det(A^{-1}) = 1/det(A)

---

### 3. Что такое алгебраическое дополнение элемента матрицы?

**Алгебраическое дополнение** элемента a_{ij} матрицы A — число, вычисляемое по формуле:

```
A_{i,j} = (-1)^{i+j} × M_{i,j}
```

где M_{i,j} — **минор** элемента a_{ij}, то есть определитель матрицы, полученной из исходной матрицы A путём вычёркивания i-й строки и j-го столбца.

**Пример:**
```
Для матрицы A = ⎡ 1  2  3 ⎤
                ⎢ 4  5  6 ⎥
                ⎣ 7  8  9 ⎦

Минор M_{1,1} = | 5  6 | = 5×9 - 6×8 = 45 - 48 = -3
                | 8  9 |

A_{1,1} = (-1)^{1+1} × M_{1,1} = 1 × (-3) = -3
```

**Знак алгебраического дополнения** определяется по **шахматному правилу**:
```
⎡ +  -  +  -  + ... ⎤
⎢ -  +  -  +  - ... ⎥
⎢ +  -  +  -  + ... ⎥
⎢ -  +  -  +  - ... ⎥
⎣ ...              ⎦
```

**Применение:**
Алгебраические дополнения используются для:
1. Вычисления определителя (разложение по строке или столбцу)
2. Построения обратной матрицы
3. Решения систем линейных уравнений (правило Крамера)

---

### 4. Как графически найти решение целевой функции?

**Графический метод** решения целевой функции F(t) = min{max{V₁(t), V₂(t)}} (для нечётного варианта) включает следующие этапы:

**Шаг 1:** Построить графики обеих функций V₁(t) и V₂(t) на заданном интервале [-4π; 3π].

**Шаг 2:** Построить огибающую функцию F_max(t) = max{V₁(t), V₂(t)}, которая в каждой точке принимает наибольшее из значений V₁ и V₂.

**Шаг 3:** Найти минимум огибающей функции на заданном интервале.

**Шаг 4:** Координаты точки минимума (t_min, F_min) являются решением задачи.

**Для чётного варианта** задача формулируется как F(t) = max{...}, и тогда ищется максимум огибающей.

**В нашем случае (вариант 7 — нечётный):**
1. Построены графики V₁(t) = 5cos(t) + 0.7cos(3t) и V₂(t) = 2.5 + t
2. Построена огибающая max(V₁, V₂)
3. Найден минимум огибающей: **t_min ≈ -10.5, F_min ≈ -5.5**

**Графическая интерпретация:**
- Огибающая max(V₁, V₂) представляет собой кусочно-гладкую функцию
- В точках пересечения V₁ и V₂ происходит переключение между функциями
- Минимум огибающей может находиться либо в точке пересечения, либо в локальном минимуме одной из функций

---

### 5. Что такое минор матрицы и как его найти?

**Минор M_{i,j}** — определитель матрицы, полученной из исходной матрицы A путём **вычёркивания i-й строки и j-го столбца**.

**Алгоритм нахождения минора M_{i,j}:**

1. Взять исходную матрицу A размера n×n
2. Вычеркнуть i-ю строку
3. Вычеркнуть j-й столбец
4. Вычислить определитель получившейся матрицы размера (n-1)×(n-1)

**Пример:**
```
Для матрицы A = ⎡ 1  2  3 ⎤
                ⎢ 4  5  6 ⎥
                ⎣ 7  8  9 ⎦

Найти M_{2,3} (вычеркиваем 2-ю строку и 3-й столбец):

M_{2,3} = | 1  2 | = 1×8 - 2×7 = 8 - 14 = -6
          | 7  8 |
```

**Главные (диагональные) миноры** — это миноры элементов, лежащих на главной диагонали:
- M_{1,1}, M_{2,2},
